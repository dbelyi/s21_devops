#!/bin/bash

# Возвращает общее количество папок в заданной директории и всех ее поддиректориях
function total_folders {
    # Переменная num получает значение, подсчитанное с помощью команды find
    # Команда find используется для поиска файлов и каталогов в заданном директории и его поддиректориях
    # Флаг -type d указывает, что нужны только директории
    # Команда wc -l используется для подсчета числа строк вывода команды find, которые соответствуют найденным папкам
    num="`find $1 -type d | wc -l`"
    echo $(( num - 1))
}

# Выводит топ-5 папок в заданной директории $1 в порядке убывания их размера
function top_5 {
    # Используем команду du для подсчета размера каждой папки в указанной директории, и сортируем результаты в обратном порядке (-nr)
    # Затем используем команду head для выбора первых пяти строк вывода, которые содержат информацию о наиболее крупных папках
    output="`du -h $1 | sort -nr | head -5`"
    declare -a arr
    # Преобразуем строку вывода в массив arr
    arr=($output)
    counter=0
    # Содержит количество строк вывода, которые были выбраны с помощью команды head
    # Каждый элемент массива arr содержит размер файла или папки, а следующий элемент содержит имя файла или папки
    # Таким образом, размеры хранятся в четных индексах, а имена в нечетных
    check_5=$(( ${#arr[@]} / 2 ))
    echo "len is $check_5"

    # Используем цикл for для вывода топ-5 файлов или папок в формате путь и размер
    # Переменная counter используется для доступа к соответствующим элементам массива arr при выводе
    for (( a = 1; a <= $check_5; a++ ))
    do
        echo "$a - ${arr[$counter + 1]}, ${arr[$counter]}"
        counter=$[ $counter + 2 ]
    done
}

# Возвращает количество файлов в заданном каталоге и всех его подкаталогах
function total_files {
    # Используем команду find для поиска всех файлов в каталоге и его подкаталогах
    # Опция -type f означает, что нужно искать только файлы
    # Затем результаты передаются в команду wc с опцией -l, которая возвращает количество строк вывода, т.е. количество файлов
    num="`find $1 -type f | wc -l`"
    echo $num
}

# Получает имя файла в качестве входного параметра, затем извлекает имя файла без пути к нему, используя оператор ## и
# Удаляет все символы, кроме расширения файла с помощью ##*.
function get_extension {
    file=$1
    new=${file##*/}
    # Проверяем, есть ли у файла расширение, сравнивая имя файла со своим суффиксом
    # Если суффикс не существует, то функция возвращает строку no extension
    # В противном случае функция возвращает расширение файла.
    if [[ $new = ${new##*.} ]]; then
        echo "no extension"
    else
        echo ${new##*.}
    fi
}

# Выводит информацию о 10 наибольших файлах в указанной директории (и ее поддиректориях) вместе с их размерами и расширениями файлов
function top_10_size {
    # Используем команду find для поиска всех файлов (-type f) в указанной директории и ее поддиректориях
    # Команда sort -r сортирует вывод по убыванию размера файлов
    # Команда head -10 выбирает только первые 10 строк из отсортированного вывода
    # Команда awk используется для выделения размера каждого файла и его имени, которое может содержать пробелы
    output2="`find $1 -type f -exec du -h {} + | sort -r | head -10 | awk '{print $1}'`"
    OLDIFS=IFS
    IFS=$'\n'
    # Используем команду du -h для вывода размера каждого файла в удобном для чтения формате.
    output3="`find $1 -type f -exec du -h {} + | sort -r | head -10 | awk '{$1=""; print}'`"

    # Два массива (arr2 и arr3) заполняются данными из вывода awk, разделенными на две переменные temp2 и temp1 (размер файла и имя файла)
    declare -a arr2
    declare -a arr3
    arr2=($output2)
    arr3=($output3)
    check=$(( ${#arr2[@]} - 1 ))

    # Цикл for проходит по обоим массивам, объединяет размер и имя каждого файла и выводит информацию о каждом файле, включая его порядковый номер, имя, размер и расширение
    for (( a = 0; a <= $check; a++ ))
    do
        temp2=${arr2[$a]}
        temp1=${arr3[$a]}
        # Функция get_extension вызывается, чтобы получить расширение файла
        echo "$(( $a + 1 )) -$temp1, $temp2, $(get_extension $temp1)"
    done
    IFS=OLDIFS
}

# Находит 10 исполняемых файлов с наибольшим размером в заданной директории и выводит их информацию, включая MD5-хеш каждого файла
function top_10_exe {
    # Используется команда find, чтобы найти все исполняемые файлы в указанной директории, у которых установлен бит исполнения
    # Затем они сортируются по размеру с помощью команды sort, и первые 10 наибольших файлов выбираются с помощью head 
    output4="`find $1 -type f -perm /a=x -exec du -h {} + | sort -r | head -10 | awk '{print $1}'`"
    OLDIFS=IFS
    IFS=$'\n'
    output5="`find $1 -type f -perm /a=x -exec du -h {} + | sort -r | head -10 | awk '{$1=""; print}'`"

    # Размеры и имена файлов сохраняются в массивах arr4 и arr5
    declare -a arr4
    declare -a arr5
    arr4=($output4)
    arr5=($output5)
    check=$(( ${#arr4[@]} - 1 ))

    # Цикл for использует индексы массива, чтобы извлечь соответствующие значения размера и имени файла,
    # А также вычисленный MD5-хеш, который выводится на экран вместе с номером позиции каждого файла
    IFS=OLDIFS
    for (( a = 0; a <= $check; a++ ))
    do
        temp2=${arr4[$a]}
        temp1="`echo ${arr5[$a]} | cut -c2-`"
        temp3="`md5sum $temp1 | awk '{print $1}'`"
        echo "$(( $a + 1 )) - $temp1, $temp2, $temp3"
    done
}